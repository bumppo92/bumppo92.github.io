//let errors happen instead
const q = s => document.body.querySelector(s);
const qa = s => document.body.querySelectorAll(s);
const val = s => q(s).value;
const on = 'addEventListener';
const un = 'removeEventListener';const lib = (function () {
    const SUPPORTED_HTML_TAGS = ['div', 'p', 'button'];
    Object.freeze(SUPPORTED_HTML_TAGS);
    class Lib {
        /**
         * Check if is positive integer
        * @param {*} args
        * $@returns {Boolean} 
        */
        isPositiveInteger(...args) {
            if (args.length === 0) return false;
            for (const arg of args) {
                if (!Number.isInteger(arg) || arg < 0) return false;
            }
            return true;
        }
        /**
         * check if is number
         * @param {*} args
         * @returns {Boolean} 
         */
        isNumber(...args) {
            if (args.length === 0) return false;
            for (const arg of args) {
                if (typeof arg !== "number") return false;
                if (Number.isNaN(arg)) return false;
            }
            return true;
        }
        /**
         * @param  {...any} args
         * @returns {Boolean}
         */
        isString(...args) {
            if (args.length === 0) return false;
            for (const arg of args) {
                if (typeof arg !== 'string') return false;
            }
            return true;
        }
        /**
         * @param  {...any} args
         * @returns {Boolean}
         */
        isFunction(...args) {
            if (args.length === 0) return false;
            for (const arg of args) {
                if (typeof arg !== 'function') return false;
            }
            return true;
        }
        /**
         * rounds a number
         * if parameters are incorrect type, exception is thrown
         * @param {Number} number 
         * @param {Integer} precision
         * @returns {String}
         */
        toPrecision(number, precision) {
            if (!this.isNumber(number)) throw "invalid: not a number";
            if (!this.isPositiveInteger(precision)) throw "invalid : precision not an integer";
            let digistBeforePoint = number.toString().indexOf(".");
            if (digistBeforePoint < 0) {
                digistBeforePoint = number.toString().length;
                precision = 0;
            }
            return number.toPrecision((digistBeforePoint + precision));
        }
        /**
        * @param {string} str
        * @returns {float} 
        */
        float(str) {
            let n = Number.parseFloat(str);
            if (Number.isNaN(n)) throw "String couldn't be parsed to FLOAT";
            return n;
        }
        /**
         * @param {string} str
         * @returns {int} 
         */
        int(str) {
            let n = Number.parseInt(str);
            if (Number.isNaN(n)) throw "String couldn't be parsed to INT";
            return n;
        }
        make(tag, classesArray) {
            if (!this.isString(tag)) throw "Tag must be a string";
            if (!SUPPORTED_HTML_TAGS.includes(tag)) throw "tag not supported";
            let elem = document.createElement(tag);
            if (Array.isArray(classesArray) && classesArray.length > 0) {
                for (let cssClass of classesArray) {
                    elem.classList.add(cssClass);
                }
            }
            return elem;
        }
    }
    let l = new Lib();
    Object.freeze(l);
    return l;
}());const pop = (function () {
    class Pop {
        constructor() {
            this._prefix_ = {};
            this.prefix = 'alert';
            this.prefix = 'confirm';
            this.prefix = 'prompt';
            Object.freeze(this._prefix_);
        }
        get prefix() {
            return this._prefix_;
        }
        set prefix(str) {
            if (!lib.isString(str)) throw "prefix must be string";
            this._prefix_[str] = `pop_${str}`;
        }
        alert(message) {
            if (this.isOpen('alert')) throw "popup of this type is already open";
            let prefix = this.prefix.alert;
            if (typeof message !== 'string') throw "Message must be string";
            let box = lib.make('div', ['pop', 'box']);
            box.id = `${prefix}_box`;
            let close = lib.make('div', ['pop', 'close']);
            let button = lib.make('button', ['pop', 'close']);
            button.id = `${prefix}_close`;
            button.textContent = 'X';
            let textbox = lib.make('div');
            textbox.textContent = message;
            close.appendChild(button);
            box.appendChild(close);
            box.appendChild(textbox);
            document.body.appendChild(box);
            button.addEventListener('click', this.close.bind(this, 'alert'));
        }
        isOpen(type) {
            if (!this.prefix.hasOwnProperty(type)) throw "please specify valid popup type";
            let box = q(`#${this.prefix[type]}_box`);
            return !(box === null);
        }
        close(type) {
            if (!this.prefix.hasOwnProperty(type)) throw "please specify valid popup type";
            let box = q(`#${this.prefix[type]}_box`);
            if (box === null) throw "no popup of such type is open";
            if (box.parentNode === null || box.parentNode === undefined) throw "no parent node";
            box.parentNode.removeChild(box);
        }
    }
    const p = new Pop();
    Object.freeze(p);
    return p;
}())
const convert = (function () {
    const UNITS = ['Inches', 'Centimetres', 'Millimetres']

    const all = (num, div) => {
        if (!lib.isNumber(num, div)) throw "not a number";
        if (num < 0 || div < 0) throw "negative numbers not allowed";
        return num / div;
    }
    const cmtoi = (cm) => all(cm, 2.54);
    const cmtomm = (cm) => all(cm, 0.1);
    const mmtoi = (mm) => all(mm, 25.4);
    const mmtocm = (mm) => all(mm, 10);
    const itocm = (i) => all(i, (1 / 2.54));
    const itomm = (i) => all(i, (1 / 25.4));

    const getUnitShort = (u) => {
        if (!UNITS.includes(u)) throw { message: "unsupported unit" };
        let us;
        switch (u) {
            case 'Inches':
                us = "i";
                break;
            case 'Centimetres':
                us = "cm";
                break;
            case 'Millimetres':
                us = "mm";
                break;
        }
        return us;
    }

    let c = { cmtoi, cmtomm, mmtoi, mmtocm, itocm, itomm, getUnitShort };
    Object.freeze(c);
    return c;
}());const CURRENT_SUPPORTED_TRANSLATIONS = ['eng', 'geo'];
Object.freeze(CURRENT_SUPPORTED_TRANSLATIONS);

const TRANSLATE_DATA = {
    inches: {
        geo: 'დუიმი',
        eng: 'Inches'
    },
    millimetres: {
        geo: 'მილიმეტრი',
        eng: 'Millimetre'
    },
    centimetres: {
        geo: 'სანტიმეტრი',
        eng: 'Centimetres'
    },
    diagonal: {
        geo: 'დიაგონალი',
        eng: 'Diagonal'
    },
    aspect_ratio: {
        geo: 'შეფარდება',
        eng: 'Aspect Ratio'
    },
    physical_dims_label: {
        geo: 'სიგრძე და სიგანე',
        eng: 'Width and Height'
    },
    resolutions: {
        geo: 'გაფართოება',
        eng: 'Resolution'
    },
    pixels_per_unit: {
        geo: 'პიქსელები',
        eng: 'Pixels'
    },
    popup_text: {
        geo: 'გამოიყენეთ ღილაკები ბოქლომით რათა ველის მნიშვნელობა უცვლელი '
            .concat('გახადოთ, დააჭირეთ ღილაკს ისრებით  ველების ერთმანეთთან ')
            .concat('დასაკავშირებლად (განსაკავშირებლად).\n')
            .concat('პიქსელები აღნიშნავს პიქსელების რაოდენობას არჩეულ ')
            .concat('სიგრძის ერთეულზე'),
        eng: 'Use Lock icons to freeze input\'s value, click button with arrows '
            .concat('to link (unlink) on input values (width to height for example); ')
            .concat('so they change together.\n')
            .concat('Pixels indicate number of pixels per user chosen length unit')
    }
}

Object.freeze(TRANSLATE_DATA);const UNITS = ["Inches", "Centimetres", "Millimetres"];
Object.freeze(UNITS);
class Screen {
    constructor(w, h, ppu, u) {
        const inner = {};//private fields
        // this.Width = w;
        // this.Height = h;
        // this.PixelsPerUnit = ppu;
        // this.Ratio1 = (w / h) * 9;
        // this.Ratio2 = 9;
        // this.ResolutionWidth = Math.round(this.PixelsPerUnit * this.Width);
        // this.ResolutionHeight = Math.round(this.PixelsPerUnit * this.Height);
        // this.Unit = u;
        // this.Language = 'eng';
        this.bindFunctionsToInnerFields(inner);
    }
    bindFunctionsToInnerFields(inner) {
        if (typeof inner !== 'object') {
            throw new Error("Inner field must be an object, this style to work !")
        }
        this.getWidth = this.getWidth.bind(this, inner);
        this.setWidth = this.getWidth.bind(this, inner);
        this.getHeight = this.getWidth.bind(this, inner);
        this.setHeight = this.getWidth.bind(this, inner);
    }
    getWidth(p) {
        return p.width;
    }
    setWidth(p, w) {
        if (!lib.isNumber(w)) throw " width is not a number";
        if (w < 0) throw "width is a negative number";
        p.width = w;
    }
    getHeight(p) {
        return p.height;
    }
    setHeight(p, h) {
        if (!lib.isNumber(h)) throw new Error("height is not a number");
        if (h < 0) throw new Error("height is a negative number");
        p.height = h;
    }
    getDiagonal() {
        let hs = Math.pow(this.Height, 2);
        let ws = Math.pow(this.Width, 2);
        return Math.sqrt(ws + hs);
    }
    setDiagonal(d) {
        if (!lib.isNumber(d)) throw "diagonal is not a number";
        if (d < 0) throw "diagonal is a negative number";
        this._diagonal_ = d;
    }
    getPixelsPerUnit() {
        return this._pixels_per_unit_;
    }
    setPixelsPerUnit(ppu) {
        if (!lib.isNumber(ppu)) throw "pixels_per_unit is not a number";
        if (ppu < 0) throw "pixels_per_unit is a negative number";
        this._pixels_per_unit_ = ppu;
    }
    getResolutionWidth() {
        return this._res_width_;
    }
    setResolutionWidth(w) {
        if (!lib.isNumber(w)) throw "resolution : width is not a number";
        if (w < 0) throw "resolution : width is a negative number";
        this._res_width_ = Math.round(w);
    }
    getResolutionHeight() {
        return this._res_height_;
    }
    setResolutionHeight(h) {
        if (!lib.isNumber(h)) throw "resolution : height is not a number";
        if (h < 0) throw "resolution :height is a negative number";
        this._res_height_ = Math.round(h);
    }
    getUnit() {
        return this._unit_;
    }
    setUnit(u) {
        if (!UNITS.includes(u)) throw "Incompatible unit";
        this._unit_ = u;
    }
    getRatio1() {
        return this._ratio1_;
    }
    setRatio1(r) {
        if (!lib.isNumber(r)) throw "ratio1 is not a number";
        if (r < 0) throw "ratio1 is a negative number";
        this._ratio1_ = r;
    }
    getRatio2() {
        return this._ratio2_;
    }
    setRatio2(r) {
        if (!lib.isNumber(r)) throw "ratio2 is not a number";
        if (r < 0) throw "ratio2 is a negative number";
        this._ratio2_ = r;
    }
    getLanguage() {
        return this._language_;
    }
    setLanguage(l) {
        if (!lib.isString(l)) throw "Language must be a string";
        if (!CURRENT_SUPPORTED_TRANSLATIONS.includes(l)) throw "language not supported";
        this._language_ = l;
    }
}//glue code between html(view) and model
class Presenter {
    constructor(model) {
        if (!(model instanceof Screen)) {
            throw {
                message: "argument type:screen, not passed"
            };
        }
        this.model = model;
        this._dom_ = {};
        this.setupDom();
        this.setupHandlers();
    }
    get dom() {
        return this._dom_;
    }
    //this indeed effectively ovverrides = operator
    //as it adds property intead of reassigning
    set dom(prop) {
        let elem = q(`#${prop}`);
        if (elem === undefined || elem === null) throw "dom element not found";
        this._dom_[prop] = elem;
    }
    setupDom() {
        const arr = ['Ratio1', 'Ratio2', 'Diagonal', 'Width', 'Height',
            'PixelsPerUnit', 'ResolutionWidth', 'ResolutionHeight', 'inches',
            'centi', 'milli', 'eng', 'geo', 'question'];
        for (const str of arr) this.dom = str;
    }
    setupHandlers() {
        this.setupElementFocusHandler('Ratio1', 'onRatio1Change');
        this.setupElementFocusHandler('Ratio2', 'onRatio2Change');

        this.setupElementFocusHandler('Width', 'onWidthChange');
        this.setupElementFocusHandler('Height', 'onHeightChange');

        this.setupElementFocusHandler('Diagonal', 'onDiagonalChange');

        this.setupElementFocusHandler('ResolutionWidth', 'onResolutionWidthChange');
        this.setupElementFocusHandler('ResolutionHeight', 'onResolutionHeightChange');

        this.setupElementFocusHandler('PixelsPerUnit', 'onPixelsPerUnitChange');

        this.dom.milli[on]('click', this.onUnitChangeMM.bind(this));
        this.dom.centi[on]('click', this.onUnitChangeCM.bind(this));
        this.dom.inches[on]('click', this.onUnitChangeIn.bind(this));
        //
        this.dom.eng[on]('click', this.translate.bind(this, 'eng'));
        this.dom.geo[on]('click', this.translate.bind(this, 'geo'));

        //question mark
        this.dom.question[on]('click', this.onQuestionPopupAlert.bind(this));
    }
    setupElementFocusHandler(el, func) {
        if (!this.dom[el]) {
            throw { message: 'arg1: el not found in dom' }
        }
        if (!lib.isFunction(this[func])) {
            throw { message: 'arg2 function needed, not paseed' };
        }
        this.dom[el][on]('focus', e => {
            this.dom[el][on]('change', this[func].bind(this))
        });
        this.dom[el][on]('focusout', e => {
            this.dom[el][un]('change', this[func].bind(this))
        });
    }
    display() {
        this.dom.Ratio1.value = lib.toPrecision(this.model.Ratio1, 2);
        this.dom.Ratio2.value = lib.toPrecision(this.model.Ratio2, 2);
        this.dom.Diagonal.value = lib.toPrecision(this.model.Diagonal, 2);
        this.dom.Width.value = lib.toPrecision(this.model.Width, 2);
        this.dom.Height.value = lib.toPrecision(this.model.Height, 2);

        this.dom.PixelsPerUnit.value = lib.toPrecision(this.model.PixelsPerUnit, 2);
        this.dom.ResolutionWidth.value = this.model.ResolutionWidth;
        this.dom.ResolutionHeight.value = this.model.ResolutionHeight;
    }
    onRatio1Change() {
        this.model.Ratio1 = Number(this.dom.Ratio1.value);
        let ratio = this.model.Ratio1 / this.model.Ratio2;
        this.model.Width = this.model.Height * ratio;
        this.model.ResolutionWidth = this.model.Width * this.model.PixelsPerUnit;
        this.model.ResolutionHeight = this.model.Height * this.model.PixelsPerUnit;
        this.display();
    }
    onRatio2Change() {
        this.model.Ratio2 = Number(this.dom.Ratio2.value);
        let ratio = this.model.Ratio1 / this.model.Ratio2;
        this.model.Width = this.model.Height * ratio;
        this.model.ResolutionWidth = this.model.Width * this.model.PixelsPerUnit;
        this.model.ResolutionHeight = this.model.Height * this.model.PixelsPerUnit;
        this.display();
    }
    onWidthChange() {
        this.model.Width = Number(this.dom.Width.value);
        let ratio = this.model.Width / this.model.Height;
        this.model.Ratio1 = ratio * this.model.Ratio2;
        this.model.ResolutionWidth = this.model.PixelsPerUnit * this.model.Width;
        this.model.Diagonal = Math.sqrt(Math.pow(this.model.Width, 2) + Math.pow(this.model.Height, 2));
        this.display();
    }
    onHeightChange() {
        this.model.Height = Number(this.dom.Height.value);
        let ratio = this.model.Width / this.model.Height;
        this.model.Ratio2 = this.model.Ratio1 / ratio;
        this.model.ResolutionHeight = this.model.PixelsPerUnit * this.model.Height;
        this.model.Diagonal = Math.sqrt(Math.pow(this.model.Width, 2) + Math.pow(this.model.Height, 2));
        this.display();
    }
    onDiagonalChange() {
        this.model.Diagonal = Number(this.dom.Diagonal.value);
        const ratio = this.model.Ratio1 / this.model.Ratio2;
        const rs = ratio * ratio;
        const ds = Math.pow(this.model.Diagonal, 2)
        this.model.Height = Math.sqrt(ds / (1 + rs));
        this.model.Width = this.model.Height * ratio;
        this.model.ResolutionWidth = this.model.PixelsPerUnit * this.model.Width;
        this.model.ResolutionHeight = this.model.PixelsPerUnit * this.model.Height;
        this.display();
    }
    onResolutionWidthChange() {
        this.model.ResolutionWidth = Number(this.dom.ResolutionWidth.value);
        this.model.Width = this.model.ResolutionWidth / this.model.PixelsPerUnit;
        let ratio = this.model.Width / this.model.Height;
        this.model.Ratio1 = ratio * this.model.Ratio2;
        this.model.Diagonal = Math.sqrt(Math.pow(this.model.Width, 2) + Math.pow(this.model.Height, 2));
        this.display();
    }
    onResolutionHeightChange() {
        this.model.ResolutionHeight = Number(this.dom.ResolutionHeight.value);
        this.model.Height = this.model.ResolutionHeight / this.model.PixelsPerUnit;
        let ratio = this.model.Width / this.model.Height;
        this.model.Ratio2 = this.model.Ratio1 / ratio;
        this.model.Diagonal = Math.sqrt(Math.pow(this.model.Width, 2) + Math.pow(this.model.Height, 2));
        this.display();
    }
    onPixelsPerUnitChange() {
        this.model.PixelsPerUnit = Number(this.dom.PixelsPerUnit.value)
        this.model.ResolutionWidth = this.model.PixelsPerUnit * this.model.Width;
        this.model.ResolutionHeight = this.model.PixelsPerUnit * this.model.Height;
        this.display();
    }
    onUnitChangeMM() {
        this.dom.inches.classList.remove('darkness');
        this.dom.centi.classList.remove('darkness');
        this.dom.milli.classList.add('darkness');

        let unit = this.model.Unit;
        this.model.Unit = "Millimetres";
        this.onUnitChange(unit);
        this.dom.PixelsPerUnit.setAttribute('step', '0.01');
    }
    onUnitChangeCM() {
        this.dom.inches.classList.remove('darkness');
        this.dom.milli.classList.remove('darkness');
        this.dom.centi.classList.add('darkness');

        let unit = this.model.Unit;
        this.model.Unit = "Centimetres";
        this.onUnitChange(unit);
        this.dom.PixelsPerUnit.setAttribute('step', '0.01');
    }
    onUnitChangeIn() {
        this.dom.centi.classList.remove('darkness');
        this.dom.milli.classList.remove('darkness');
        this.dom.inches.classList.add('darkness');

        let unit = this.model.Unit;
        this.model.Unit = "Inches";
        this.onUnitChange(unit);
        this.dom.PixelsPerUnit.setAttribute('step', '1');
    }
    onUnitChange(unitFrom) {
        let f, func;//function, function name;
        const u1 = convert.getUnitShort(unitFrom);
        const u2 = convert.getUnitShort(this.model.Unit);

        func = `${u1}to${u2}`;
        f = convert[func];

        this.model.Width = f(this.model.Width);
        this.model.Height = f(this.model.Height);
        this.model.Diagonal = f(this.model.Diagonal);
        this.model.PixelsPerUnit = this.model.PixelsPerUnit / f(1);
        if (u2 === 'i') {
            this.model.PixelsPerUnit = lib.toPrecision(this.model.PixelsPerUnit, 0);
        }
        this.display();
    }

    onQuestionPopupAlert() {
        pop.alert(TRANSLATE_DATA['popup_text'][this.model.Language]);
    }
    translate(lang) {
        if (lang === 'geo') {
            this.dom.eng.classList.remove('darkness');
            this.dom.geo.classList.add('darkness');
        }
        if (lang === 'eng') {
            this.dom.geo.classList.remove('darkness');
            this.dom.eng.classList.add('darkness');
        }
        let translatables = qa('[data-app-translate="1"]');
        for (let i = 0, len = translatables.length; i < len; i++) {
            let text = translatables[i].getAttribute('data-app-text');
            translatables[i].textContent = TRANSLATE_DATA[text][lang];
        }
        this.model.Language = lang;
    }
}//prevent form submiting
//q("form")[on]('submit', e => e.preventDefault());

try {
    let screen = new Screen(5.7, 3, 403, "Inches");
    let presenter = new Presenter(screen);
    presenter.display();
}
catch (ex) {
    if (ex.message) console.error(ex.message);
    console.log(ex);
}
